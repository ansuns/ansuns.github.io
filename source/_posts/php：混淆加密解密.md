---
title: 混淆加密解密
abbrlink: 6d5007a7
date: 2019-07-25 16:06:36
tags:
  - PHP
  - 后端
categories:
  - 技术
  - PHP
---
php混淆加密解密
 
php做为一门当下非常流行的web语言，常常看到有人求解密php文件，想当年的asp也是一样。一些人不理解为什么要混淆(加密)，甚至鄙视混淆(加密)，在我看来混淆加密代码可以用来防一般的小人，会起到一定的保护作用。
 
加密的原因：
 
1. 保护代码，防止别人剽窃
 
2. 保护文件，防止别人发现/查杀(php木马 or 后门)
 
3. 剽窃了他人代码防止被发现
 
4. 其他商业或非商业目的
 
第一种加密方式，就是简单的使用函数encode代码之后，再eval(decode('encode的代码')),解密非常简单，直接把eval替换成exit即可输出源代码，如果经过多层加密，就继续替换下去...
 
eval(base64_decode('PD9waHAgZWNobyAndHh0Y21zLmNvbSc7Pz4='));
解密难度：★☆☆☆☆
 
第二种威盾加密，做为第一种方式的升级版，即把之前的base64之类的系统内置函数变成了匿名函数。解密也是一样把eval替换成exit即可。
 
$OOO0O0O00=__FILE__;$OOO000000=urldecode('%74%68%36%73%62%65%68%71%6c%61%34%63%6f%5f%73%61%64%66%70%6e%72');$OO00O0000=28;$OOO0000O0=$OOO000000{4}.$OOO000000{9}.$OOO000000{3}.$OOO000000{5};$OOO0000O0.=$OOO000000{2}.$OOO000000{10}.$OOO000000{13}.$OOO000000{16};$OOO0000O0.=$OOO0000O0{3}.$OOO000000{11}.$OOO000000{12}.$OOO0000O0{7}.$OOO000000{5};$O0O0000O0='OOO0000O0';eval(($$O0O0000O0('JE9PME9PMDAwMD.//......省略
解密难度：★★☆☆☆
 
第三种Zend Guard,这种加密方式无法像前面一样手动解密。需要用到工具，如：dezender黑刀。 目前我知道的就只有php4~php5.2的可以被此工具解密出来，解密出来的变量或函数可能比较丑像$_obfuscate开头，因为经过混淆了。不过如果在php代码里加上一句代码，可使该程序溢出导致解密失败。
 
@Zend; 3074; 以下省略乱码
解密难度：★★★★☆
 
第四种二进制(unicode乱码)加密，如phpjm,phpdp神盾。这种加密方式其实也是威盾的升级版，即把匿名函数字符串经过一系列的打乱分散处理之后，再把函数、变量、字符串替换成经过处理的unicode字符串。这样生成的文件就不能轻易的修改了。加大了解密的难度，解密方法也简单，就是替换掉那些变量和方法，使之成为正常的字符串，再exit即可。
 
if (!defined("BEEABDD")){define("BEEABDD", __FILE__);global $?$妰,$唽,$墎儢,$唫敊?$槀垙梽,$厠墪儛?$嚌巵嚀亸,$寬剛檲槗,$拹枩崄厷?$湠湜啔増仦?$憻檮劀瀺晵€?$垵啑崙媺悎剹,$倧€剮寳崊湌倹€,$槏偀梹啅€攢専挄,$剦槙姙儣枓瀿厐巼;function 殸($殸,$妰?""){.......
解密难度：★★★★☆
 
总结：
1；php无扩展加密无非用到的几个函数 eval , preg_replace使用e修饰符 , strtr , base64_decode。
2；收费的放弃；
3；需要安装额外扩展的，例如bcompiler，放弃；
4；混淆只会为程序添加另一层潜在的错误和安全漏洞（PS）；
5；目的为了防小人，所以做简单的代码混淆；

--------------------------------------------------------------------------------
 
测试了多个开源库，以下这个较为理想；
混淆过程：


混淆结果：



 a；文件多行代码会合并为少量几行代码；
  b；类的共有方法不会修改；只混淆私有方法，常量不会混淆；方法或函数的参数混淆；
  c；混淆 后代码运行正常；

理论上可行；这是研究的结果；
 