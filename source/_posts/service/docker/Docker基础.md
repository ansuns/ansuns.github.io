---
title: Docker基础
tags:
  - 容器
  - docker
  - 虚拟化
  - 自动化
categories:
  - 服务
  - docker
abbrlink: 1d9fbb6a
date: 2018-02-15 22:23:17
---

Docker 包括三个基本概念 **镜像（ Image ）** **容器（ Container ）** **仓库（ Repository ）**

--------------------------------------------------------------------------------

使用 Docker 镜像
从 Docker 镜像仓库获取镜像的命令是 docker pull，其命令格式为：
```bash
 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

```bash
docker pull ubuntu:16.04
```

且进行交互式操作
```bash
docker run -it --rm ubuntu:16.04 bash
```

--------------------------------------------------------------------------------

Dockerfile
```bash
FROM nginx
RUN test='ls -a' \
    && echo '<h1>Hello, Docker!<h1>' > /usr/share/nginx/html/index.html \
    && mkdir /usr/share/nginx/html/test \
    && cd /usr/share/nginx/html/test \
    && touch index.php \
    && echo '<?php echo "Hello Wolrd!"; ?>' > index.php $test
```

然后在 Dockerfile 文件所在目录执行：
```bash
docker build -t nginx:v3 .
```
就可以构建一个镜像啦

--------------------------------------------------------------------------------


镜像构建上下文（Context）

我是这么理解的：

{% asset_img 1.png 上下文 %}
````bash
FROM nginx
COPY ./123t /usr/share/nginx/html/tttttttttt
RUN test='ls -a' \
    && echo '<h1>Hello, Docker!<h1>' > /usr/share/nginx/html/index.html \
    && mkdir /usr/share/nginx/html/test \
    && cd /usr/share/nginx/html/test \
    && touch index.php \
    && echo '<?php echo "Hello Wolrd!"; ?>' > index.php \
    && cd /usr/share/nginx/html $test
````

buidl时，会吧123t复制到 当前上下文，但是没有到镜像中，执行COPY命令后，就把123t复制到镜像啦

--------------------------------------------------------------------------------

ENTRYPOINT 入口点

```bash
FROM ubuntu:16.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT ["curl", "-s", "http://ip.cn"]
```

--------------------------------------------------------------------------------

VOLUME 定义匿名卷
容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存 动态数据的应用，其数据库文件应该保存于卷(volume)中

--------------------------------------------------------------------------------

EXPOSE 声明端口

EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声 明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助 镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用 随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。

--------------------------------------------------------------------------------

WORKDIR 指定工作目录 
格式为 WORKDIR <工作目录路径> 。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改 为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录

--------------------------------------------------------------------------------

USER 指定当前用户 
格式： USER <用户名> USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目 录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。

--------------------------------------------------------------------------------

操作 Docker 容器
简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可 以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应 用。

--------------------------------------------------------------------------------

启动容器 
启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态 （ stopped ）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。
 新建并启动 所需要的命令主要为 docker run 。 
$ docker run -t -i ubuntu:14.04 /bin/bash root@af8bae53bdd3:/# 其中， -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。

--------------------------------------------------------------------------------

当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 
检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止

--------------------------------------------------------------------------------

导出和导入容器 
导出容器 如果要导出本地某个容器，可以使用 docker export 命令

--------------------------------------------------------------------------------

清理所有处于终止状态的容器 用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太 多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 $ docker container prune

--------------------------------------------------------------------------------

访问仓库
根据是否是官方提供，可将镜像资源分为两类。 一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创 建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。 还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有 用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 tianon 用 户。

--------------------------------------------------------------------------------

推送镜像 
用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。

--------------------------------------------------------------------------------


私有仓库 

安装运行 docker-registry 容器运行 你可以通过获取官方 registry 镜像来运行。
 ```bash
 docker run -d -p 5000:5000 --restart=always --name registry registry 
 ```
 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参
 数来将镜像文件存放在本地的指定路径。例 如下面的 例子将上传的镜像放到本地的 /opt/data/registry 目录:
 ```bash
 docker run -d \ -p 5000:5000 \ -v /opt/data/registry:/var/lib/registry \ registry 
 ```
 在私有仓库上传、搜索、下载镜像 创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如 私有仓库地址为 127.0.0.1:5000

http://192.168.99.100:5000/

```bash
docker tag myip:latest 192.168.99.100:5000/myip:latest
```

--------------------------------------------------------------------------------

数据卷：
**数据卷**是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用对
数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除，注意： 数据卷 的使用，类似
于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂 载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷 。 选择 -v 
还是 **--mount** 参数 Docker 新用户应该选择 **--mount** 参数，经验丰富的 Docker 使用者对 -v 或者 **--volume** 已经很熟悉了，但是推
荐使用 **--mount** 参数。 
>创建一个数据卷
```bash
docker volume create my-vol 
```
>查看所有的 数据卷
```bash
docker volume ls local my-vol
``` 
>在主机里使用以下命令可以查看指 数据卷的信息
```bash
 docker volume inspect my-vol
```

--------------------------------------------------------------------------------

容器互联：
新建网络 ：
```bash
 docker network create -d bridge my-net
```

--------------------------------------------------------------------------------
Compose

使用 术语 首先介绍几个术语。 服务 ( service )：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 ( project )：由一组
关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成， Compose 面向项目进行管理。 
场景最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。 下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站




